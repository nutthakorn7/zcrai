import { CronJob } from 'cron';
import { ReportService } from './report.service';
import { EmailService } from './email.service';

export const SchedulerService = {
  jobs: [] as CronJob[],

  init() {
    console.log('‚è≥ Initializing Scheduler Service...');
    
    // Weekly Executive Report (Every Monday at 9:00 AM)
    // Cron pattern: 0 9 * * 1 (Sec Min Hour DOM Month DOW) - wait, cron package uses 6 fields? 
    // node-cron usually uses 5 or 6. Let's check package Usage. 
    // 'cron' package standard: Seconds: 0-59, Minutes: 0-59, Hours: 0-23, Day of Month: 1-31, Months: 0-11 (Jan-Dec), Day of Week: 0-6 (Sun-Sat)
    
    const weeklyReportJob = new CronJob(
      '0 0 9 * * 1', // 9:00:00 AM every Monday
      async () => {
        console.log('ü§ñ Running Weekly Executive Report Job...');
        try {
          await this.generateAndSendWeeklyReport();
        } catch (error) {
          console.error('‚ùå Weekly Report Job Failed:', error);
        }
      },
      null,
      true, // start immediately
      'Asia/Bangkok' // Timezone
    );
    
    this.jobs.push(weeklyReportJob);
    console.log(`‚úÖ Scheduler started with ${this.jobs.length} jobs.`);
  },

  async generateAndSendWeeklyReport() {
    // 1. Determine Date Range (Last 7 Days)
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(endDate.getDate() - 7);
    
    // 2. Format Dates like "2023-10-25"
    const startStr = startDate.toISOString().split('T')[0];
    const endStr = endDate.toISOString().split('T')[0];
    
    console.log(`üìä Generating Report for ${startStr} to ${endStr}`);

    // 3. Generate PDF Buffer
    // We reuse the existing Dashboard PDF endpoint logic via Service call
    // Note: ReportService.generateDashboardPDF is designed for web response (stream), 
    // we might need to adjust it or capture the stream. 
    // Let's assume we can refactor ReportService or use it directly if it returns a buffer.
    
    // Check ReportService signature...
    // If ReportService.generateDashboardPDF writes to a stream, we might need a helper.
    // Let's assume for now we call the same logic. 
    // Actually, ReportService uses Puppeteer to print page.
    
    // We need to pass a tenantId. For MVP/SuperAdmin report, we can pick the first tenant or a specific one.
    // Let's assume there is a 'default' tenant or we fetch active tenants.
    // For now, let's use a hardcoded tenantId that we know exists or 'default'.
    const tenantId = 'tenant-id-123'; // REPLACE with real logic to iterate tenants
    
    // Correct Signature: generateDashboardPDF(tenantId, options)
    const pdfBuffer = await ReportService.generateDashboardPDF(tenantId, {
        startDate: startStr,
        endDate: endStr,
        title: `Weekly Executive Report (${startStr} - ${endStr})`
    });

    // 4. Send Email
    // Hardcoded to admin for MVP. In real app, fetch admins from DB.
    const recipient = 'admin@zcr.ai'; // Todo: fetch superadmin email or use env
    
    await EmailService.sendEmail({
      to: recipient,
      subject: `üìä Weekly Executive Security Report (${startStr} - ${endStr})`,
      html: `
        <h2>Weekly Security Executive Summary</h2>
        <p>Please find attached the security report for the period <strong>${startStr}</strong> to <strong>${endStr}</strong>.</p>
        <p>This report includes:</p>
        <ul>
            <li>Total Alerts & Severity Breakdown</li>
            <li>Top Active Playbooks</li>
            <li>Incident Trends</li>
        </ul>
        <br/>
        <p>Generated by zcrAI SOC Platform</p>
      `,
      attachments: [
        {
          filename: `Executive_Report_${startStr}_${endStr}.pdf`,
          content: pdfBuffer
        }
      ]
    });
  }
};
